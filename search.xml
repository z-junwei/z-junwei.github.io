<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Data JPA的简单使用</title>
    <url>/2022/11/09/JPA%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>工作中偶然用到的Spring Data JPA，那就浅浅的学习一下吧！</p>
<span id="more"></span>

<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jpa--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">4652</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">&quot;update&quot;</span> <span class="comment">#自动更新</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="string">&quot;true&quot;</span>  <span class="comment">#日志中打印sql语句</span></span><br></pre></td></tr></table></figure>

<p>ddl-auto配置说明：</p>
<ul>
<li>create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</li>
<li>create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭，表就自动删除。</li>
<li>update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</li>
<li>validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</li>
</ul>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>启动会自动创建好，前提数据库要建好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;User&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span> <span class="comment">//主键自增策略，这里也可以使用自定义</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="CrudRepository"><a href="#CrudRepository" class="headerlink" title="CrudRepository"></a>CrudRepository</h4><p>可以实现简单的crud，首先要创建一个UserRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.testdemo.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"><span class="comment">//继承后可以进行简单的crud操作了，不需要额外写代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看一下<code>CrudRepository</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Iterable&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>;</span><br><span class="line">    Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Iterable&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAllById</span><span class="params">(Iterable&lt;? extends ID&gt; ids)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;find&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JpaRepository"><a href="#JpaRepository" class="headerlink" title="JpaRepository"></a>JpaRepository</h4><p>可以实现通过自己的SQL进行查询，其实大多数用的是<code>JpaRepository</code>，首先编写UserService类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.testdemo.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.query.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Query(value = &quot;select id,name,age from user  where name = :userName&quot;,nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">getUserByName</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeQuery属性说明：</p>
<ul>
<li>@Query有nativeQuery=true，表示可执行的原生sql，原生sql指可以直接复制sql语句给参数赋值就能运行，打印出来的你自己写的</li>
<li>@Query无nativeQuery=true， 表示不是原生sql，查询语句中的表名则是对应的项目中实体类的类名</li>
</ul>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findByName&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.getUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JpaSpecificationExecutor"><a href="#JpaSpecificationExecutor" class="headerlink" title="JpaSpecificationExecutor"></a>JpaSpecificationExecutor</h4><p>有时候会进行复杂查询，这时候就要继承<code>JpaSpecificationExecutor&lt;T&gt;</code>方法了，泛型内传入实体类，只要简单实现<code>toPredicate</code>方法就可以实现复杂的查询，方法中的<code>Specification</code>就是需要我们传进去的参数，它是一个接口,也是我们实现复杂查询的关键,其中只有一个方法<code>toPredicate</code></p>
<p>我们来看一看方法内部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JpaSpecificationExecutor</span>&lt;T&gt; &#123;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findOne</span><span class="params">(<span class="meta">@Nullable</span> Specification&lt;T&gt; var1)</span>;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(<span class="meta">@Nullable</span> Specification&lt;T&gt; var1)</span>;</span><br><span class="line">    Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(<span class="meta">@Nullable</span> Specification&lt;T&gt; var1, Pageable var2)</span>;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(<span class="meta">@Nullable</span> Specification&lt;T&gt; var1, Sort var2)</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">(<span class="meta">@Nullable</span> Specification&lt;T&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先UserRepository 再继承 JpaSpecificationExecutor<User>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; , JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<h5 id="单条件"><a href="#单条件" class="headerlink" title="单条件"></a>单条件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单条件：使用年龄查询</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;findUserByCond&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserByCond</span><span class="params">(<span class="meta">@RequestParam</span> String age, <span class="meta">@RequestParam</span> String name)</span>&#123;</span><br><span class="line">       <span class="type">Specification</span> <span class="variable">specification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Specification</span>() &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span> Predicate:定义了查询条件</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> root&lt;Users&gt; root:根对象。封装了查询条件的对象</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> query&lt;?&gt; query:定义了一个基本的查询。一般不使用</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> criteriaBuilder criteriaBuilder:创建一个查询条件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder)</span> &#123;</span><br><span class="line">               <span class="comment">//根据年龄</span></span><br><span class="line">               <span class="keyword">return</span> criteriaBuilder.equal(root.get(<span class="string">&quot;age&quot;</span>),age);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       List&lt;User&gt; user = userRepository.findAll(specification);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多条件：使用姓名and年龄查询</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;findUserByCond&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserByCond</span><span class="params">(<span class="meta">@RequestParam</span> String age, <span class="meta">@RequestParam</span> String name)</span>&#123;</span><br><span class="line">       <span class="type">Specification</span> <span class="variable">specification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Specification</span>() &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span> Predicate:定义了查询条件</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> root&lt;Users&gt; root:根对象。封装了查询条件的对象</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> query&lt;?&gt; query:定义了一个基本的查询。一般不使用</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> criteriaBuilder cb:创建一个查询条件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> criteriaBuilder.and(criteriaBuilder.equal(root.get(<span class="string">&quot;age&quot;</span>),age),</span><br><span class="line">                                          criteriaBuilder.equal(root.get(<span class="string">&quot;name&quot;</span>),name));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       List&lt;User&gt; user = userRepository.findAll(specification);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="分页与排序"><a href="#分页与排序" class="headerlink" title="分页与排序"></a>分页与排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页与排序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;findUserPageSort&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Page <span class="title function_">findUserPageSort</span><span class="params">(<span class="meta">@RequestParam</span> String age)</span>&#123;</span><br><span class="line">       <span class="type">Specification</span> <span class="variable">specification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Specification</span>() &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span> Predicate:定义了查询条件</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> root&lt;Users&gt; root:根对象。封装了查询条件的对象</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> query&lt;?&gt; query:定义了一个基本的查询。一般不使用</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> criteriaBuilder cb:创建一个查询条件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> criteriaBuilder.equal(root.get(<span class="string">&quot;age&quot;</span>),age);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//排序</span></span><br><span class="line">       <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">       <span class="comment">//分页</span></span><br><span class="line">       <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span>  PageRequest.of(<span class="number">0</span>,<span class="number">10</span>, sort);</span><br><span class="line">       Page&lt;User&gt; page = userRepository.findAll(specification, pageable);</span><br><span class="line">       System.out.println(<span class="string">&quot;总条数：&quot;</span>+page.getTotalElements());</span><br><span class="line">       System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getTotalPages());</span><br><span class="line">       List&lt;User&gt; users = page.getContent();</span><br><span class="line">       System.out.println(users.toString());</span><br><span class="line">       <span class="keyword">return</span> page;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/spring/202211091743708.png" alt="image-20221109174339660"></p>
<blockquote>
<p>本来打算看一下利用Spring Data JPA的多表关联查询的，看了一圈感觉好麻烦，怀念MyBatis plus!</p>
</blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/chenglc/p/11226693.html">https://www.cnblogs.com/chenglc/p/11226693.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC源码解析</title>
    <url>/2022/11/04/Spring%20IoC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Spring源码，一生之敌！</p>
<span id="more"></span>

<h2 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h2><ul>
<li>不要在意版本，核心思想不变</li>
<li>抓住骨架进行学习，覆盖所有细节难度太大<ul>
<li>解析配置</li>
<li>定位与注册对象</li>
<li>注入对象</li>
</ul>
</li>
</ul>
<h2 id="注入bean的方式"><a href="#注入bean的方式" class="headerlink" title="注入bean的方式"></a>注入bean的方式</h2><p>先演示一下两种方式获取bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WelcomeService</span> &#123;</span><br><span class="line">	String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.service.WelcomeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">WelcomeService</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello, &quot;</span> + name);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于Xml"><a href="#基于Xml" class="headerlink" title="基于Xml"></a>基于Xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;welcomeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zjw.service.impl.WelcomeServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.service.WelcomeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.zjw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entrance</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">xmlPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\study\\SpringSourceCode\\spring-framework-5.2.0.RELEASE\\springdemo\\src\\main\\resources\\spring\\spring-config.xml&quot;</span>;</span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(xmlPath);</span><br><span class="line">		<span class="type">WelcomeService</span> <span class="variable">welcomeService</span> <span class="operator">=</span> (WelcomeService) applicationContext.getBean(<span class="string">&quot;welcomeService&quot;</span>);</span><br><span class="line">		welcomeService.sayHello(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/IoCAnalysis202211041639236.png" alt="image-20221104163904204" style="zoom:67%;" />

<h3 id="基于Annotation"><a href="#基于Annotation" class="headerlink" title="基于Annotation"></a>基于Annotation</h3><p>把上面加了注解的类的注释解开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.service.WelcomeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zjw&quot;)</span><span class="comment">//扫描哪个包下，和自研类似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entrance</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Entrance.class);</span><br><span class="line">		String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">		<span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">			System.out.println(beanDefinitionName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">WelcomeService</span> <span class="variable">welcomeService</span> <span class="operator">=</span> (WelcomeService) applicationContext.getBean(<span class="string">&quot;welcomeServiceImpl&quot;</span>);</span><br><span class="line">		welcomeService.sayHello(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/IoCAnalysis202211041642538.png" alt="image-20221104164218507" style="zoom:67%;" />

<p>在该包下加了注解的类都被加载到了bean容器中。</p>
<h2 id="Bean与BeanDefinition"><a href="#Bean与BeanDefinition" class="headerlink" title="Bean与BeanDefinition"></a>Bean与BeanDefinition</h2><p><strong>Bean是Spring的一等公民：</strong></p>
<ul>
<li>Bean的本质就是java对象，只是这个对象的声明周期由容器来管理</li>
<li>不需要为了创建Bean而在原来的java类上添加任何额外的限制</li>
<li>对java对象的控制方式体现在配置上</li>
</ul>
<p><strong>根据配置，生成用来描述Bean的BeanDefinition，常用属性∶</strong></p>
<ul>
<li>作用范围scope(@Scope)</li>
<li>懒加载lazy-init(@Lazy)：决定Bean实例是否延迟加载</li>
<li>首选primary(@Primary)：设置为true的bean会是优先的实现</li>
<li>factorv-bean和factorv-method(@Confiauration和@Bean）</li>
</ul>
<h3 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.entity.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态工厂调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">	<span class="comment">//静态的方法，返回User对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.entity.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.entity.User;</span><br><span class="line"><span class="comment">//实例工厂调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">	<span class="comment">//普通的方法，返回User对象</span></span><br><span class="line">	<span class="comment">//不能通过类名调用，需要通过对象调用</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjw.entity.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> User.class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entrance</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//得到无参构造函数创建的对象:</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user1a</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user1b</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">		<span class="comment">//得到静态工厂创建的对象：</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user2a</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user2c</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line">		<span class="comment">//得到实例工厂创建的对象：</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user3a</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user3&quot;</span>);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user3b</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user3&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造函数创建的对象:&quot;</span> + user1a);</span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造函数创建的对象:&quot;</span> + user1b);</span><br><span class="line">		System.out.println(<span class="string">&quot;静态工厂创建的对象：&quot;</span> + user2a);</span><br><span class="line">		System.out.println(<span class="string">&quot;静态工厂创建的对象：&quot;</span> + user2c);</span><br><span class="line">		System.out.println(<span class="string">&quot;实例工厂创建的对象：&quot;</span> + user3a);</span><br><span class="line">		System.out.println(<span class="string">&quot;实例工厂创建的对象：&quot;</span> + user3b);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;welcomeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zjw.service.impl.WelcomeServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.使用类的无参构造函数创建 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zjw.entity.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2.使用静态工厂进行创建 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- class的值不是写User对象的全路径，而是写静态工厂的全路径 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- factory-method的值写要调用的方法 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zjw.entity.factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 3.使用实例工厂进行创建 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 需要先创建factoryBean对象，再通过factoryBean对象进行调用 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zjw.entity.factory.UserFactory&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/IoCAnalysis/202211041719374.png" alt="image-20221104171933387"></p>
<p>你会发现当scope=”singleton”，对象相同；scope=”prototype”对象不同。</p>
<h3 id="容器初始化主要步骤"><a href="#容器初始化主要步骤" class="headerlink" title="容器初始化主要步骤"></a>容器初始化主要步骤</h3><p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/IoCAnalysis/202211041725233.png" alt="image-20221104172550192"></p>
<ul>
<li>解析配置</li>
<li>定位与注册对象</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>自研IoC框架</title>
    <url>/2022/11/04/%E8%87%AA%E7%A0%94IoC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>迷你版IoC框架，简单的实现扫描配置并注入自定义的Bean容器。</p>
<span id="more"></span>

<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><strong>一个框架最基本的功能：</strong></p>
<ul>
<li>解析配置</li>
<li>定位与注册对象</li>
<li>注入对象</li>
<li>提供通用的工具类</li>
</ul>
<p><strong>IoC容器的实现：</strong></p>
<p><code>创建注解 -&gt; 提取标记对象 -&gt; 实现容器 -&gt; 依赖注入</code></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h3><p>这里注解的作用和Spring的类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//作用在类上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//运行时通过反射获取注解信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取标记对象"><a href="#提取标记对象" class="headerlink" title="提取标记对象"></a>提取标记对象</h3><p>实现思路：</p>
<ul>
<li>指定范围，获取范围内的所有类</li>
<li>遍历所有类，获取被注解标记的类并加载进容器里</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> sun.nio.cs.ext.IBM037;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.accessibility.Accessible;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PROTOCOL</span> <span class="operator">=</span> <span class="string">&quot;file&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取包下的所有类</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 需要完成的事情：</span></span><br><span class="line"><span class="comment">	 * 1、获取类的加载器：获取项目发布的实际路径</span></span><br><span class="line"><span class="comment">	 * 2、通过类加载器获取到加载的资源信息</span></span><br><span class="line"><span class="comment">	 * 3、依据不同的类型，采用不同的方式获取资源的集合</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getPackageClass(String packageName)&#123;</span><br><span class="line">		<span class="comment">//1、获取类的加载器：获取项目发布的实际路径</span></span><br><span class="line">		<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">		<span class="comment">//2、通过类加载器获取到加载的资源信息</span></span><br><span class="line">		<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> classLoader.getResource(packageName.replace(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (url == <span class="literal">null</span>)&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;unable to retrieve anything from package, &quot;</span> + packageName);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3、依据不同的类型，采用不同的方式获取资源的集合，这里只要file资源</span></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">			classSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">			<span class="type">File</span> <span class="variable">packageDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(url.getPath());</span><br><span class="line">			getClassFile(classSet, packageDirectory, packageName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> classSet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归获取</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classSet class资源的集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classSet, File fileSource, String packageName)</span> &#123;</span><br><span class="line">		<span class="comment">//如果不是文件，直接return</span></span><br><span class="line">		<span class="keyword">if</span> (!fileSource.isDirectory())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果是一个文件夹，则调用listFiles方法获取文件夹下的文件或文件夹</span></span><br><span class="line">		File[] files = fileSource.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File file)</span> &#123;</span><br><span class="line">				<span class="comment">//子目录返回true继续</span></span><br><span class="line">				<span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//获取文件的绝对路径</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">absoluteFilePath</span> <span class="operator">=</span> file.getAbsolutePath();</span><br><span class="line">					<span class="keyword">if</span> (absoluteFilePath.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">						<span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">						addToClassSet(absoluteFilePath);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToClassSet</span><span class="params">(String absoluteFilePath)</span> &#123;</span><br><span class="line">				<span class="comment">//1.从class文件的绝对路径里提取包含了package的类名</span></span><br><span class="line">				<span class="comment">//注意：路径最好不要带有中文</span></span><br><span class="line">				<span class="comment">//如：D:\study\SpringSourceCode\spring-framework-5.2.0.RELEASE\simpleframework\src\main\java\com\zjw\entity\User.java</span></span><br><span class="line">				<span class="comment">//弄成：com.zjw.entity.Student</span></span><br><span class="line">				absoluteFilePath = absoluteFilePath.replace(File.separator, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">				<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">				className = className.substring(<span class="number">0</span>, className.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">				<span class="comment">//2.通过反射获取对应的class对象并加入到classSet</span></span><br><span class="line">				<span class="type">Class</span> <span class="variable">targetClass</span> <span class="operator">=</span> loadClass(className);</span><br><span class="line">				classSet.add(targetClass);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (files != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">				<span class="comment">//递归获取</span></span><br><span class="line">				getClassFile(classSet, file, packageName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 反射获取类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Class.forName(className);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;load class error, &quot;</span>, e);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取ClassLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实例化类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> accessible:是否支持创建出私有class对象的实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">boolean</span> accessible)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">			constructor.setAccessible(accessible);</span><br><span class="line">			<span class="keyword">return</span> (T) constructor.newInstance();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;newInstance error&quot;</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置类的属性值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> field 成员变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 类实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 成员变量的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> accessible 是否允许设置私有属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(Field field, Object target, Object value, <span class="type">boolean</span> accessible)</span>&#123;</span><br><span class="line">		field.setAccessible(accessible);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			field.set(target, value);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;setField error&quot;</span>, e);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">packageDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\study\\SpringSourceCode\\spring-framework-5.2.0.RELEASE\\simpleframework\\target\\classes\\com\\zjw\\entity&quot;</span>);</span><br><span class="line">		System.out.println(packageDirectory.isDirectory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写测试类测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.core.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassUnitTest</span> &#123;</span><br><span class="line">	<span class="meta">@DisplayName(&quot;提取目标类方法：getClassPackageTest&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getClassPackageTest</span><span class="params">()</span>&#123;</span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.getPackageClass(<span class="string">&quot;com.zjw.entity&quot;</span>);</span><br><span class="line">		System.out.println(classSet);</span><br><span class="line">		Assertions.assertEquals(<span class="number">12</span>, classSet.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041602520.png" alt="image-20221104151955799"></p>
<h3 id="实现容器"><a href="#实现容器" class="headerlink" title="实现容器"></a>实现容器</h3><h4 id="单例模式问题"><a href="#单例模式问题" class="headerlink" title="单例模式问题"></a>单例模式问题</h4><p>自研容器推荐使用饿汉模式，方便简洁，但是要考虑安全性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarvingSingleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StarvingSingleton</span> <span class="variable">starvingSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarvingSingleton</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">StarvingSingleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> StarvingSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> starvingSingleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种并不安全，可以利用反射机制来破除无参构造private的防御。</p>
<blockquote>
<p><strong>反射为啥能破坏单例？</strong></p>
<p>通过反射获得单例类的构造函数，由于该构造函数是private的，通过setAccessible(true)指示反射的对象在使用时应该取消 <a href="http://lib.csdn.net/base/javase">Java</a> 语言访问检查，使得私有的构造函数能够被访问，这样使得单例模式失效。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反射破环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">		System.out.println(StarvingSingleton.getInstance());</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> StarvingSingleton.class;</span><br><span class="line">		<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">		constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">		System.out.println(constructor.newInstance());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041602014.png" alt="image-20221102105920885"></p>
<p><strong>解决办法：</strong></p>
<p>采用枚举类。</p>
<blockquote>
<p><strong>枚举为啥不能被反射破环？</strong></p>
<p>参考：<a href="https://www.cnblogs.com/call-me-pengye/p/11214435.html">https://www.cnblogs.com/call-me-pengye/p/11214435.html</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarvingSingletonEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">StarvingSingletonEnum</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> StarvingSingletonEnum <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">ContainerHolder</span>&#123;</span><br><span class="line">		HOLDER;</span><br><span class="line">		<span class="keyword">private</span> StarvingSingletonEnum instance;</span><br><span class="line">		ContainerHolder()&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">StarvingSingletonEnum</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">		System.out.println(StarvingSingletonEnum.getInstance());</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> StarvingSingletonEnum.class;</span><br><span class="line">		<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">		constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">		<span class="type">StarvingSingletonEnum</span> <span class="variable">starvingSingletonEnum</span> <span class="operator">=</span> (StarvingSingletonEnum) constructor.newInstance();</span><br><span class="line">		System.out.println(starvingSingletonEnum.getInstance());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041602966.png" alt="202211021348290"></p>
<p>直接测试枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ContainerHolder.class;</span><br><span class="line">		<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//		Constructor constructor = clazz.getDeclaredConstructor(String.class, int.class);</span></span><br><span class="line">		constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">		System.out.println(constructor.newInstance());</span><br><span class="line">		System.out.println(StarvingSingletonEnum.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041601162.png" alt="202211021349240"></p>
<h4 id="容器的组成部分"><a href="#容器的组成部分" class="headerlink" title="容器的组成部分"></a>容器的组成部分</h4><ul>
<li>保存Class对象以及其实例的载体</li>
<li>容器的加载</li>
<li>容器的操作方式</li>
</ul>
<h5 id="保存Class对象以及其实例的载体"><a href="#保存Class对象以及其实例的载体" class="headerlink" title="保存Class对象以及其实例的载体"></a>保存Class对象以及其实例的载体</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放所有被配置标记的目标对象的Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="容器的加载"><a href="#容器的加载" class="headerlink" title="容器的加载"></a>容器的加载</h5><ul>
<li>配置的管理与获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载bean的注解列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; BEAN_ANNOTATION =</span><br><span class="line">		Arrays.asList(</span><br><span class="line">				Controller.class,</span><br><span class="line">				Service.class</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定范围内的Class对象</li>
</ul>
<p>​        上面的<code>getPackageClass</code>方法。</p>
<ul>
<li>依据配置提取Class对象，连同实例一起存入容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器是否已经加载过bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loaded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否已经加载过bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoaded</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描加载所有bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">loadBeans</span><span class="params">(String packageName)</span>&#123;</span><br><span class="line">	<span class="comment">//判断bean容器是否被加载过</span></span><br><span class="line">	<span class="keyword">if</span> (loaded == <span class="literal">true</span>)&#123;</span><br><span class="line">		log.warn(<span class="string">&quot;BeanContainer has been loaded......&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.getPackageClass(packageName);</span><br><span class="line">	<span class="keyword">if</span> (ValidationUtil.isEmpty(classSet))&#123;</span><br><span class="line">		log.warn(<span class="string">&quot;get nothing from packageName &quot;</span> + packageName);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation : BEAN_ANNOTATION) &#123;</span><br><span class="line">			<span class="comment">//如果类上面标记了定义的注解</span></span><br><span class="line">			<span class="keyword">if</span> (clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">				<span class="comment">//将本类作为键，目标类的实例作为值，存入Map</span></span><br><span class="line">				beanMap.put(clazz, ClassUtil.newInstance(clazz, <span class="literal">true</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.core.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationUtil</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(Collection&lt;?&gt; obj)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (obj == <span class="literal">null</span> || obj.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(String obj)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (obj == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(obj));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(Object[] obj)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (obj == <span class="literal">null</span> || obj.length == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(Map&lt;?, ?&gt; obj)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (obj == <span class="literal">null</span> || obj.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>BeanContainer完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.IoC.core.annotation.Component;</span><br><span class="line"><span class="keyword">import</span> org.IoC.core.annotation.Controller;</span><br><span class="line"><span class="keyword">import</span> org.IoC.core.annotation.Repository;</span><br><span class="line"><span class="keyword">import</span> org.IoC.core.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.IoC.utils.ClassUtil;</span><br><span class="line"><span class="keyword">import</span> org.IoC.utils.ValidationUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanContainer</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 存放所有被配置标记的目标对象的Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 加载bean的注解列表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; BEAN_ANNOTATION =</span><br><span class="line">			Arrays.asList(</span><br><span class="line">					Component.class,</span><br><span class="line">					Controller.class,</span><br><span class="line">					Repository.class,</span><br><span class="line">					Service.class</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取Bean的容器实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> BeanContainer <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取beans的数量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeanSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> beanMap.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 枚举</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">ContainerHolder</span>&#123;</span><br><span class="line">		HOLDER;</span><br><span class="line">		<span class="keyword">private</span> BeanContainer instance;</span><br><span class="line">		ContainerHolder()&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">BeanContainer</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 容器是否已经加载过bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loaded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否已经加载过bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoaded</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> loaded;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 扫描加载所有bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">loadBeans</span><span class="params">(String packageName)</span>&#123;</span><br><span class="line">		<span class="comment">//判断bean容器是否被加载过</span></span><br><span class="line">		<span class="keyword">if</span> (loaded == <span class="literal">true</span>)&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;BeanContainer has been loaded......&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.getPackageClass(packageName);</span><br><span class="line">		<span class="keyword">if</span> (ValidationUtil.isEmpty(classSet))&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;get nothing from packageName &quot;</span> + packageName);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation : BEAN_ANNOTATION) &#123;</span><br><span class="line">				<span class="comment">//如果类上面标记了定义的注解</span></span><br><span class="line">				<span class="keyword">if</span> (clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">					<span class="comment">//将本类作为键，目标类的实例作为值，存入Map</span></span><br><span class="line">					beanMap.put(clazz, ClassUtil.newInstance(clazz, <span class="literal">true</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(beanMap);</span><br><span class="line">		loaded = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置类的属性值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> field 成员变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 类实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 成员变量的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> accessible 是否允许设置私有属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(Field field, Object target, Object value, <span class="type">boolean</span> accessible)</span>&#123;</span><br><span class="line">		field.setAccessible(accessible);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			field.set(target, value);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;setField error&quot;</span>, e);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写测试类测试BeanContainer：</p>
<p>测试之前要记得在com.zjw包下面的impl、controller下的方法分别加上自定义的注解@Service、@Controller，我这里总数为2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanContainerTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> BeanContainer beanContainer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@BeforeAll</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">		beanContainer = BeanContainer.getInstance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeansTest</span><span class="params">()</span>&#123;</span><br><span class="line">		Assertions.assertEquals(<span class="literal">false</span>, beanContainer.isLoaded());</span><br><span class="line">		beanContainer.loadBeans(<span class="string">&quot;com.zjw&quot;</span>);</span><br><span class="line">		Assertions.assertEquals(<span class="number">2</span>, beanContainer.getBeanSize()); <span class="comment">// 我只加了两处</span></span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.isLoaded());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果编译成功，说明加了自定义注解的类已经被成功放入到了Map中，打印一下beanMap看看。</p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041600688.png" alt="image-20221102160914939"></p>
<h5 id="容器的操作方式"><a href="#容器的操作方式" class="headerlink" title="容器的操作方式"></a>容器的操作方式</h5><p>涉及到容器的增删改查</p>
<ul>
<li>增加、删除操作</li>
<li>根据Class获取对应实例</li>
<li>获取所有的Class和实例</li>
<li>通过注解来获取被注解标注的Class</li>
<li>通过超类获取对应的子类Class</li>
<li>获取容器载体保存Class的数量</li>
</ul>
<p>下面的方法都写在BeanContainer类下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">addBeans</span><span class="params">(Class&lt;?&gt; clazz, Object bean)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanMap.put(clazz, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">removeBeans</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanMap.remove(clazz);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取bean实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanMap.get(clazz);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取容器管理的所有Class对象集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses()&#123;</span><br><span class="line">		<span class="keyword">return</span> beanMap.keySet();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有的bean集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">getBeans</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(beanMap.values());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据注解筛选出Bean的Class集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesByAnnotation(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation)&#123;</span><br><span class="line">		<span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">		<span class="keyword">if</span> (ValidationUtil.isEmpty(keySet))&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;nothing in beanMap&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.通过注解筛选被注解标记的class对象，并添加到classSet中</span></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : keySet) &#123;</span><br><span class="line">			<span class="comment">//类是否有相关的注解标记</span></span><br><span class="line">			<span class="keyword">if</span> (clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">				classSet.add(clazz);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> classSet.size() &gt; <span class="number">0</span> ? classSet : <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过接口或者父类获取实现类或者子类的Class集合，不包括其本身</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> interfaceOrClass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesBySuper(Class&lt;?&gt; interfaceOrClass)&#123;</span><br><span class="line">		<span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">		<span class="keyword">if</span> (ValidationUtil.isEmpty(keySet))&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;nothing in beanMap&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.判断keySet中的元素是否是传入的接口或者类的子类，是的话添加到classSet中</span></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : keySet) &#123;</span><br><span class="line">			<span class="comment">//判断keySet中的元素是否是传入的接口或者类的子类</span></span><br><span class="line">			<span class="keyword">if</span> (interfaceOrClass.isAssignableFrom(clazz) &amp;&amp; !clazz.equals(interfaceOrClass))&#123;</span><br><span class="line">				classSet.add(clazz);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> classSet.size() &gt; <span class="number">0</span> ? classSet : <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试某些方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定测试类的执行顺序</span></span><br><span class="line"><span class="meta">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanContainerTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> BeanContainer beanContainer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@BeforeAll</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">		beanContainer = BeanContainer.getInstance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DisplayName(&quot;测试容器：loadBeansTest&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="meta">@Order(1)</span> <span class="comment">//最先执行,表示要先加载容器,获取bean，才能执行后面的getBean等方法。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeansTest</span><span class="params">()</span>&#123;</span><br><span class="line">		Assertions.assertEquals(<span class="literal">false</span>, beanContainer.isLoaded());</span><br><span class="line">		beanContainer.loadBeans(<span class="string">&quot;com.zjw&quot;</span>);</span><br><span class="line">		Assertions.assertEquals(<span class="number">2</span>, beanContainer.getBeanSize());</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.isLoaded());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DisplayName(&quot;根据类Class获取实例：getBeanTest&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="meta">@Order(2)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getBeanTest</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//可以获取</span></span><br><span class="line">		<span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> (UserController) beanContainer.getBean(UserController.class);</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, userController <span class="keyword">instanceof</span> UserController);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//不可以获取</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) beanContainer.getBean(User.class);</span><br><span class="line">		Assertions.assertEquals(<span class="literal">null</span>, user);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DisplayName(&quot;根据注解类型获取对应的实例：getClassesByAnnotationTest&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="meta">@Order(3)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getClassesByAnnotationTest</span><span class="params">()</span>&#123;</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.isLoaded());</span><br><span class="line">		Assertions.assertEquals(<span class="number">1</span>, beanContainer.getClassesByAnnotation(Controller.class).size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DisplayName(&quot;根据接口获取实现类：getClassesBySuperTest&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="meta">@Order(4)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getClassesBySuperTest</span><span class="params">()</span>&#123;</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.isLoaded());</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.getClassesBySuper(UserService.class).contains(UserServiceImpl.class));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041559274.png" alt="image-20221102172418850"></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>目前容器里面管理的Bean实例仍可能是不完备的</p>
<ul>
<li>实例里面某些必须的成员变量还没有被创建出来</li>
</ul>
<p>例如，需要添加类似@Autowired的注解将其注入。</p>
<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041603678.png" alt="202211041600589" style="zoom:67%;" />

<p><strong>实现思路：</strong></p>
<ul>
<li>定义相关的注解标签</li>
<li>实现创建被注解标记的成员变量实例，并将其注入到成员变量里</li>
<li>依赖注入的使用</li>
</ul>
<h4 id="定义相关的注解标签"><a href="#定义相关的注解标签" class="headerlink" title="定义相关的注解标签"></a>定义相关的注解标签</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.inject.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目前支持成员变量注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">	<span class="comment">//用来处理一个接口有多个是实现类的情况,可以给实现类定义一个value区分</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现依赖注入"><a href="#实现依赖注入" class="headerlink" title="实现依赖注入"></a>实现依赖注入</h4><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041604539.png" alt="202211041449933" style="zoom:67%;" />

<p><strong>思路（以上图为例）：</strong></p>
<ol>
<li>首先要获取单例bean容器<code>BeanContainer</code>，目的是将@Controller标记的UserController加载到容器中。</li>
<li>再通过容器获取UserController的Class对象，取出所有的属性（userService、name）。</li>
<li>再筛选出被@Autowired标记的属性（userService）。</li>
<li>获取成员变量的类型。获取这些成员变量的类型在容器里对应的实例（这里UserServiceImpl被@Service标记的）。</li>
<li>通过反射将对应的成员变量实例注入到成员变量所在类的实例里。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.IoC.core.BeanContainer;</span><br><span class="line"><span class="keyword">import</span> org.IoC.inject.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.IoC.utils.ClassUtil;</span><br><span class="line"><span class="keyword">import</span> org.IoC.utils.ValidationUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInjector</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bean容器 单例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> BeanContainer beanContainer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DependencyInjector</span><span class="params">()</span>&#123;</span><br><span class="line">		beanContainer = BeanContainer.getInstance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行IoC</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIoC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ValidationUtil.isEmpty(beanContainer.getClasses()))&#123;</span><br><span class="line">			log.warn(<span class="string">&quot;empty classSet in BeanContainer&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.遍历Bean容器中所有的类对象</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : beanContainer.getClasses()) &#123;</span><br><span class="line">			<span class="comment">// 2.遍历Class对象的所有成员变量</span></span><br><span class="line">			Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">			<span class="comment">//如果为空，则遍历下一个class</span></span><br><span class="line">			<span class="keyword">if</span> (ValidationUtil.isEmpty(fields))&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;获取到的成员变量：&quot;</span> + Arrays.toString(fields));</span><br><span class="line">			<span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">				<span class="comment">// 3.找出被Autowired标记的成员变量</span></span><br><span class="line">				<span class="keyword">if</span> (field.isAnnotationPresent(Autowired.class))&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;筛选出被Autowire标记的成员变量：&quot;</span> + field);</span><br><span class="line">					<span class="type">Autowired</span> <span class="variable">autowired</span> <span class="operator">=</span> field.getAnnotation(Autowired.class);</span><br><span class="line">					<span class="type">String</span> <span class="variable">autowiredValue</span> <span class="operator">=</span> autowired.value();</span><br><span class="line">					<span class="comment">// 4.获取这些成员变量的类型</span></span><br><span class="line">					Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">					<span class="comment">// 5.获取这些成员变量的类型在容器里对应的实例</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">fieldValue</span> <span class="operator">=</span> getFieldInstance(fieldClass, autowiredValue);</span><br><span class="line">					<span class="keyword">if</span> (fieldValue == <span class="literal">null</span>)&#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unable to inject relevant type, target fieldClass is: &quot;</span></span><br><span class="line">								+ fieldClass.getName() + autowiredValue);</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 6.通过反射将对应的成员变量实例注入到成员变量所在类的实例里</span></span><br><span class="line">						<span class="type">Object</span> <span class="variable">targetBean</span> <span class="operator">=</span> beanContainer.getBean(clazz);</span><br><span class="line">						ClassUtil.setField(field, targetBean, fieldValue, <span class="literal">true</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据Class在beanContainer里获取其实例或者实现类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fieldClass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> autowiredValue</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">getFieldInstance</span><span class="params">(Class&lt;?&gt; fieldClass, String autowiredValue)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">fieldValue</span> <span class="operator">=</span> beanContainer.getBean(fieldClass);</span><br><span class="line">		<span class="comment">//直接可以获取到，比如@Contoller标记的</span></span><br><span class="line">		<span class="keyword">if</span> (fieldValue != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> fieldValue;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果是接口，那么你要获取他的是实现类@Service</span></span><br><span class="line">			Class&lt;?&gt; implementedClass = getImplementClass(fieldClass, autowiredValue);</span><br><span class="line">			<span class="keyword">if</span> (implementedClass != <span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> beanContainer.getBean(implementedClass);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; getImplementClass(Class&lt;?&gt; fieldClass, String autowiredValue) &#123;</span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesBySuper(fieldClass);</span><br><span class="line">		<span class="keyword">if</span> (!ValidationUtil.isEmpty(classSet))&#123;</span><br><span class="line">			<span class="comment">//默认value为空</span></span><br><span class="line">			<span class="keyword">if</span> (ValidationUtil.isEmpty(autowiredValue))&#123;</span><br><span class="line">				<span class="comment">//只有一个是实现类</span></span><br><span class="line">				<span class="keyword">if</span> (classSet.size() == <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> classSet.iterator().next();</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//如果多于两个实现类并且没有指定value，则抛出异常</span></span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;multiple implement class for &quot;</span> + fieldClass.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">                    <span class="comment">//找到匹配的value</span></span><br><span class="line">					<span class="keyword">if</span> (autowiredValue.equals(clazz.getSimpleName()))&#123;</span><br><span class="line">						<span class="keyword">return</span> clazz;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试一下：</strong></p>
<p><strong>1、UserService只有一个实现类UserServiceImpl。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.IoC.inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjw.controller.UserController;</span><br><span class="line"><span class="keyword">import</span> org.IoC.core.BeanContainer;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInjectorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DisplayName(&quot;依赖注入doIoC&quot;)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIoCTest</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">BeanContainer</span> <span class="variable">beanContainer</span> <span class="operator">=</span> BeanContainer.getInstance();</span><br><span class="line">		beanContainer.loadBeans(<span class="string">&quot;com.zjw&quot;</span>);</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, beanContainer.isLoaded());</span><br><span class="line">		<span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> (UserController) beanContainer.getBean(UserController.class);</span><br><span class="line">		Assertions.assertEquals(<span class="literal">true</span>, userController <span class="keyword">instanceof</span> UserController);</span><br><span class="line">		<span class="comment">//UserController要加上@Getter注解，以获取注入的service实例</span></span><br><span class="line">		Assertions.assertEquals(<span class="literal">null</span>, userController.getUserService());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">DependencyInjector</span>().doIoC();</span><br><span class="line">		Assertions.assertNotEquals(<span class="literal">null</span>, userController.getUserService());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041557805.png" alt="image-20221104151225991"></p>
<p><strong>2、UserService只有一个实现类UserServiceImpl、UserServiceImpl2。</strong></p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041557984.png" alt="image-20221104151327098"></p>
<p>给@Autowired指定value值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired(value = &quot;UserServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041557562.png" alt="image-20221104151527252"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/MySelfIoC/202211041557293.jpeg" alt="1667547977897"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>初始Kafka</title>
    <url>/2022/05/04/%E5%88%9D%E8%AF%86Kafka/</url>
    <content><![CDATA[<p>阅读《深入理解Kafka》笔记，对生产者、消费者以及基本架构有了初步的认识。</p>
<span id="more"></span>

<h2 id="初始Kafka"><a href="#初始Kafka" class="headerlink" title="初始Kafka"></a>初始Kafka</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个典型的 Kafka 体系架构包括若干 Producer、若干 Broker、若干Consumer，以及一个ZooKeeper集群。<br>其中ZooKeeper是Kafka用来负责集群元数据（包括集群、broker、主题、分区等内容）的管理、控制器的选举等操作的。Producer将消息发送到Broker，Broker负责将收到的消息存储到磁盘中，而Consumer负责从Broker订阅并消费消息。</p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101629056.jpg" alt="L3Byb3h5L2h0dHBzL2ltZy5sdW96aGl5dW4uY29tL2Jsb2cxNjk0OWJkNjI3OWRmMTA2LnBuZw=="></p>
<p>主要名词解释：<br><strong>Producer</strong>：<br>生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。<br><strong>Consumer</strong>：<br>消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。<br><strong>Broker</strong>：<br>服务代理节点。大多数情况下也可以将Broker看作一台Kafka服务器，多个则组成集群。<br><strong>Topic</strong>：<br>主题。生产者负责将消息发送到特定的主题（发送到Kafka集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。主题可以细分为多个分区。<br><strong>Partition</strong>：<br>分区。一个分区只属于单个主题，同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件（顺序追加），消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset)。<br>每一条消息被发送到broker之前，会根据分区规则选择存储到哪个具体的分区。能够解决I/O性能瓶颈。<br>例如：</p>
<blockquote>
<p>主题中有 4 个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个broker，以此来提供比单个broker更强大的性能。</p>
</blockquote>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101631824.png" alt="image-20221110163131768"><br><strong>offset</strong>：<br>偏移量。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区内的顺序性。<br><strong>Replica</strong>：<br>副本。Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样)，副本之间是“一主多从”的关系，其中<strong>leader副本负责处理读写请求</strong>，<strong>follower副本只负责与leader副本的消息同步</strong>。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。<br>例如：</p>
<blockquote>
<p>Kafka集群中有4个broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follower副本中的消息相对leader副本而言会有一定的滞后。</p>
</blockquote>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101631931.png" alt="image-20221110163156868"><br>副本细分：</p>
<blockquote>
<ul>
<li><strong>AR（Assigned Replicas）</strong>：分区中的所有副本统称为AR。</li>
<li><strong>ISR（In-Sync Replicas）</strong>：所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR，ISR集合是AR集合中的一个子集。ISR与HW和LEO也有紧密的关系。</li>
<li><strong>OSR（Out-of-Sync Replicas）</strong>：与leader副本同步滞后过多的副本（不包括leader副本）组成OSR。</li>
</ul>
</blockquote>
<p>由此可见，AR=ISR+OSR。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR集合为空。</p>
<blockquote>
<p>leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR集合中的副本则没有任何机会（不过可以通过配置修改）。</p>
</blockquote>
<blockquote>
<ul>
<li><strong>HW（High Watermark）</strong>：高水位。它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。</li>
</ul>
<p>例如：日志文件中有 9 条消息，第一条消息的 offset（LogStartOffset）为0，最后一条消息的offset为8，offset为9的消息用虚线框表示，代表下一条待写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在0至5之间的消息，而offset为6的消息对消费者而言是不可见的。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101632133.png" alt="image-20221110163226089"></p>
<ul>
<li><strong>LEO（Log End Offset）：</strong>它标识当前日志文件中下一条待写入消息的offset，上图offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR集合中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。</li>
</ul>
</blockquote>
<blockquote>
<p>案例说明：假设某个分区的ISR集合中有3个副本，即一个leader副本和2个follower副本，此时分区的LEO和HW都为3。</p>
<ol>
<li>消息3和消息4从生产者发出之后会被先存入leader副本。</li>
</ol>
</blockquote>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101632885.png" alt="image-20221110163255844"></p>
<blockquote>
<ol>
<li>在消息写入leader副本之后，follower副本会发送拉取请求来拉取消息3和消息4以进行消息同步。</li>
</ol>
</blockquote>
<p>!<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101633782.png" alt="image-20221110163311730"></p>
<blockquote>
<p>由于不同的 follower 副本的同步效率也不尽相同，会出现不同情况。<br>（1）在某一时刻follower1完全跟上了leader副本而follower2只同步了消息3，如此leader副本的LEO为5，follower1的LEO为5，follower2的LEO为4，那么当前分区的HW取最小值4，此时消费者可以消费到offset为0至3之间的消息。<br>!<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101633615.png" alt="image-20221110163330563"><br>（2）写入消息（情形4）如图1-8所示，所有的副本都成功写入了消息3和消息4，整个分区的HW和LEO都变为5，因此消费者可以消费到offset为4的消息了。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101633483.png" alt="image-20221110163345439"></p>
</blockquote>
<h3 id="生产与消费"><a href="#生产与消费" class="headerlink" title="生产与消费"></a>生产与消费</h3><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;topic-demo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        </span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line">        <span class="comment">// 构建需要发送的信息</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, <span class="string">&quot;hello, kafka!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;topic-demo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> <span class="string">&quot;group.demo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        properties.put(<span class="string">&quot;group.id&quot;</span>, groupId);</span><br><span class="line">        </span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="comment">// 订阅主题 topic</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环消费</span></span><br><span class="line">        <span class="keyword">while</span> (isRunning。get()) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以控制什么时候，在那个位置停止消费</span></span><br><span class="line">            isRunning.set(<span class="literal">false</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><p>一个正常的生产逻辑需要具备以下几个步骤：<br>（1）配置生产者客户端参数及创建相应的生产者实例。<br>（2）构建待发送的消息。<br>（3）发送消息。<br>（4）关闭生产者实例。</p>
<p><strong>生产者客户端示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;topic-demo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        </span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line">        <span class="comment">// 构建需要发送的信息</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, <span class="string">&quot;hello, kafka!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KafkaProducer是线程安全的，可以在多个线程中共享单个KafkaProducer实例，也可以将KafkaProducer实例进行池化来供其他线程调用。</p>
<p><strong>ProducerRecord</strong>：构建消息的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerRecord</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic; <span class="comment">//主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition; <span class="comment">//分区号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers; <span class="comment">//消息头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key; <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value; <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp; <span class="comment">//消息的时间戳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key：是用来指定消息的键，它不仅是消息的附加信息，还可以用来计算分区号进而可以让消息发往特定的分区。可以让消息再进行二次归类，同一个key的消息会被划分到同一个分区中</p>
<h4 id="必要的参数配置"><a href="#必要的参数配置" class="headerlink" title="必要的参数配置"></a>必要的参数配置</h4><p><strong>bootstrap.servers：</strong><br>该参数用来指定生产者客户端连接Kafka集群所需的broker地址清单，具体的内容格式为host1：port1，host2：port2，可以设置一个或多个地址，中间以逗号隔开，此参数的默认值为“”。注意这里并非需要所有的broker地址，因为生产者会从给定的broker里查找到其他broker的信息。不过建议至少要设置两个以上的broker 地址信息，当其中任意一个宕机时，生产者仍然可以连接到 Kafka集群上。<br><strong>key.serializer 和 value.serializer：</strong><br>broker 端接收的消息必须以字节数组（byte[]）的形式存在。代码清单2-1中生产者使用的KafkaProducer＜String，String＞和ProducerRecord＜String，String＞中的泛型＜String，String＞对应的就是消息中key和value的类型，生产者客户端使用这种方式可以让代码具有良好的可读性，不过在发往broker之前需要将消息中对应的key和value做相应的序列化操作来转换成字节数组。</p>
<p><strong>简化配置参数代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,brokerList);</span><br><span class="line">properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class="line">properties.put(ProducerConfig.CLIENT_ID_CONFIG,<span class="string">&quot;test01&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h4><p>ProducerRecord对象用来构建消息，其中topic属性和value属性是必填项，其余属性是选填项，有多种构造方法。<br>发送消息主要有三种模式：</p>
<ul>
<li>发后即忘（fire-and-forget）</li>
<li>同步（sync）</li>
<li>异步（async）</li>
</ul>
<p><strong>发后即忘（fire-and-forget）：</strong><br>它只管往Kafka中发送消息而并不关心消息是否正确到达。在大多数情况下，这种发送方式没有什么问题，不过在某些时候（比如发生不可重试异常时）会造成消息的丢失。这种发送方式的性能最高，可靠性也最差。<br><strong>同步（sync）：</strong><br>KafkaProducer 的 send（）方法是 Future＜RecordMetadata＞类型，有两个重载方法：<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101635631.png" alt="image-20221110163554583"></p>
<blockquote>
<p>可以利用返回的Future对象实现同步发送的方式</p>
</blockquote>
<p><strong>实现同步发送方式：</strong></p>
<ol>
<li><p>调用get（）方法阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式调用了get（）方法来阻塞等待Kafka的响应，直到消息发送成功，或者发生异常。</span></span><br><span class="line"><span class="comment">//如果发生异常，那么就需要捕获异常并交由外层逻辑处理。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取RecordMetadata对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//producer.send(record).get();</span></span><br><span class="line">    Future&lt;RecordMetadata&gt; future = producer.send(record);</span><br><span class="line">    <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(metadata.topic() + <span class="string">&quot;==&quot;</span> +</span><br><span class="line">                       metadata.partition() + <span class="string">&quot;==&quot;</span> +</span><br><span class="line">                       metadata.offset());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印：*******topic-demo==<span class="number">0</span>==<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>RecordMetadata对象里包含了消息的一些元数据信息，比如当前消息的主题、分区号、分区中的偏移量（offset）、时间戳等。RecordMetadata对象里包含了消息的一些元数据信息，比如当前消息的主题、分区号、分区中的偏移量（offset）、时间戳等。<br>Future 表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或取消，以及获取任务的结果和取消任务等。既然KafkaProducer.send（）方法的返回值是一个Future类型的对象，那么完全可以用Java语言层面的技巧来丰富应用的实现，比如使用Future中的** get（long timeout，TimeUnit unit）方法实现可超时的阻塞**。</p>
<blockquote>
<p>同步发送的方式可靠性高，要么消息被发送成功，要么发生异常。如果发生异常，则可以捕获并进行相应的处理，而不会像“发后即忘”的方式直接造成消息的丢失。不过同步发送的方式的性能会差很多，需要阻塞等待一条消息发送完之后才能发送下一条。</p>
</blockquote>
</li>
</ol>
<p><strong>异步（async）：</strong><br>一般是在send（）方法里指定一个Callback的回调函数，Kafka在返回响应时调用该函数来实现异步的发送确认。</p>
<blockquote>
<p>问题：send（）方法的返回值类型就是Future，而Future本身就可以用作异步的逻辑处理，为什么不用？<br>Future里的 get（）方法在何时调用，以及怎么调用都是需要面对的问题，消息不停地发送，那么诸多消息对应的Future对象的处理难免会引起代码处理逻辑的混乱</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送成功。。。。。&quot;</span>);</span><br><span class="line">                System.out.println(recordMetadata.topic() + <span class="string">&quot;==&quot;</span> +</span><br><span class="line">                                   recordMetadata.partition() + <span class="string">&quot;==&quot;</span> +</span><br><span class="line">                                   recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onCompletion（）方法的两个参数是互斥的，消息发送成功时，metadata 不为 null 而exception为null；消息发送异常时，metadata为null而exception不为null。<br>对于同一个分区而言，如果消息record1于record2之前先发送（参考上面的示例代码），那么KafkaProducer就可以保证对应的callback1在callback2之前调用，也就是说，<strong>回调函数的调用也可以保证分区有序</strong>。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>生产者需要用序列化器（Serializer）把对象转换成字节数组才能通过网络发送给Kafka。而在对侧，消费者需要用反序列化器（Deserializer）把从 Kafka 中收到的字节数组转换成相应的对象。<br>生产者使用的序列化器和消费者使用的反序列化器是需要一一对应的，如果生产者使用了某种序列化器，比如StringSerializer，而消费者使用了另一种序列化器，比如IntegerSerializer，那么是无法解析出想要的数据的。<br>可以自己定义哦。</p>
<h4 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h4><p>消息在通过send（）方法发往broker的过程中，有可能需要经过拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）的一系列作用之后才能被真正地发往 broker。序列化器是必需的。消息经过序列化之后就需要确定它发往的分区，如果消息ProducerRecord中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。如果消息ProducerRecord中没有指定partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值。<br>Kafka中提供的默认分区器是：org.apache.kafka.clients.producer.internals.DefaultPartitioner<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101636253.png" alt="image-20221110163621196"><br>partition（)方法中定义了主要的分区分配逻辑。</p>
<ul>
<li>如果 key 不为 null，那么默认的分区器会对 key 进行哈希（采用MurmurHash2算法，具备高运算性能及低碰撞率），最终根据得到的哈希值来计算分区号（所有分区中的任意一个），拥有相同key的消息会被写入同一个分区。</li>
<li>如果key为null，那么消息将会以轮询的方式发往主题内的各个可用分区。</li>
</ul>
<p><strong>自定义的分区器：</strong><br>只需同DefaultPartitioner一样实现Partitioner接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootkafka.chapter02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.PartitionInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.utils.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zjw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 2022/7/18 16:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes,</span></span><br><span class="line"><span class="params">                         Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitionInfos = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numPartitions</span> <span class="operator">=</span> partitionInfos.size();</span><br><span class="line">        <span class="keyword">if</span> (keyBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter.getAndIncrement() % numPartitions;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现自定义的DemoPartitioner类之后，需要通过配置参数partitioner.class来显式指定这个分区器。</p>
<blockquote>
<p>properties.put(ProducerConfig.<em>PARTITIONER_CLASS_CONFIG</em>,DemoPartitioner.class.getName());</p>
</blockquote>
<h4 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h4><p>Kafka一共有两种拦截器：生产者拦截器和消费者拦截器。生产者拦截器既可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。<br><strong>实现：</strong>自定义实现org.apache.kafka.clients.producer.ProducerInterceptor接口<br>!<img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101636862.png" alt="image-20221110163659818"></p>
<ul>
<li>onSend：在将消息序列化和计算分区之前会调用生产者拦截器的onSend（）方法来对消息进行相应的定制化操作。</li>
<li>onAcknowledgement：在消息被应答（Acknowledgement）之前或消息发送失败时调用生产者拦截器的 onAcknowledgement（）方法，优先于用户设定的 Callback 之前执行。运行在Producer 的 I/O 线程中，所以这个方法中实现的代码逻辑越简单越好，否则会影响消息的发送速度。</li>
<li>close：用于在关闭拦截器时执行一些资源的清理工作</li>
</ul>
<p><strong>自定义拦截器：</strong><br>为每条消息添加一个前缀“prefix1-”，并且通过onAcknowledgement（）方法来计算发送消息的成功率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootkafka.chapter02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> zjw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Create</span> 2022/7/18 16:33</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerInterceptorPrefix</span> <span class="keyword">implements</span> <span class="title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">sendSuccess</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">sendFailure</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为每条消息加上 ”prefix1-&quot; 的前缀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">modifiedVal</span> <span class="operator">=</span> <span class="string">&quot;prefix1-&quot;</span> + record.value();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(record.topic(), record.partition(),</span><br><span class="line">                                    record.timestamp(), record.key(), modifiedVal, record.headers());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">            sendSuccess++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendFailure++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">successRatio</span>  <span class="operator">=</span> (<span class="type">double</span>)(sendSuccess / (sendFailure + sendSuccess));</span><br><span class="line">        System.out.println(<span class="string">&quot;成功率: &quot;</span> + String.format(<span class="string">&quot;%f&quot;</span>, successRatio));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 KafkaProducer 的配置参数interceptor.classes中指定这个拦截器，此参数的默认值为“”</p>
<blockquote>
<p>properties.put(ProducerConfig.<em>INTERCEPTOR_CLASSES_CONFIG</em>,ProducerInterceptorPrefix.class.getName());</p>
</blockquote>
<p>然后使用指定了ProducerInterceptorPrefix的生产者连续发送10条内容为“kafka”的消息，结果如下：<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101637474.png" alt="image-20221110163725437"><br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101637763.png" alt="image-20221110163734714"></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>消息在真正发往Kafka之前，有可能需要经历拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）等一系列的作用，那么在此之后又会发生什么呢？<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101637062.png" alt="image-20221110163751973"></p>
<p>整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和Sender线程（发送线程）。<br>主线程：<br>KafkaProducer创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到消息累加器（RecordAccumulator，也称为消息收集器）中<br>RecordAccumulator：<br>主要用来缓存消息以便 Sender 线程可以<strong>批量发送</strong>，进而减少网络传输的资源消耗以提升性能。</p>
<ol>
<li>主线程中发送过来的消息都会被追加到RecordAccumulator的某个<strong>双端队列</strong>（Deque：具有队列和栈的性质）中，在 RecordAccumulator 的内部为每个分区都维护了一个双端队列，队列中的内容就是ProducerBatch，即 Deque＜ProducerBatch＞。消息写入缓存时，追加到双端队列的尾部；Sender读取消息时，从双端队列的头部读取。注意ProducerBatch不是ProducerRecord，<strong>ProducerBatch中可以包含一至多个ProducerRecord</strong>。通俗地说，<strong>ProducerRecord 是生产者中创建的消息，而ProducerBatch是指一个消息批次</strong>，ProducerRecord会被包含在ProducerBatch中，这样可以使字节的使用更加紧凑。与此同时，将较小的ProducerRecord拼凑成一个较大的ProducerBatch，也可以减少网络请求的次数以提升整体的吞吐量。</li>
<li>消息在网络上都是以字节（Byte）的形式传输的，在发送之前需要创建一块内存区域来保存对应的消息。在Kafka生产者客户端中，<strong>通过java.io.ByteBuffer实现消息内存的创建和释放</strong>。不过频繁的创建和释放是比较耗费资源的，在RecordAccumulator的内部还有一个BufferPool，它主要用来实现ByteBuffer的复用，以实现缓存的高效利用。不过BufferPool只针对特定大小的ByteBuffer进行管理（<strong>特定的大小由batch.size参数来指定</strong>）。</li>
</ol>
<p>Sender线程：<br>Sender 线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。</p>
<ol>
<li>Sender 从 RecordAccumulator 中获取缓存的消息之后，会进一步将原本＜分区，Deque＜ProducerBatch＞＞的保存形式转变成<strong>＜Node，List＜ProducerBatch＞</strong>的形式，其中Node表示Kafka集群的broker节点。<ul>
<li>对于网络连接来说，生产者客户端是与具体的broker节点建立的连接，也就是向具体的 broker 节点发送消息，而并不关心消息属于哪一个分区；</li>
<li>而对于 KafkaProducer的应用逻辑而言，我们只关注向哪个分区中发送哪些消息，所以在这里需要做一个应用逻辑层面到网络I/O层面的转换。</li>
</ul>
</li>
<li>在转换成＜Node，List＜ProducerBatch＞＞的形式之后，Sender 还会进一步封装成<strong>＜Node，Request＞</strong>的形式，这样就可以将Request请求发往各个Node了，这里的Request是指Kafka的各种协议请求，对于消息发送而言就是指具体的ProduceRequest</li>
<li>请求在从Sender线程发往Kafka之前还会保存到<strong>InFlightRequests</strong>中，InFlightRequests保存对象的具体形式为 Map＜NodeId，Deque＜Request＞＞，它的主要作用是缓存了已经发出去但还没有收到响应的请求（NodeId 是一个String 类型，表示节点的 id 编号）。<h4 id="元数据的更新"><a href="#元数据的更新" class="headerlink" title="元数据的更新"></a>元数据的更新</h4>InFlightRequests还可以获得<strong>leastLoadedNode</strong>，即所有Node中负载最小的那一个（这里的负载最小是通过每个Node在InFlightRequests中还未确认的请求决定的，未确认的请求越多则认为负载越大）。<strong>选择leastLoadedNode发送请求可以使它能够尽快发出，避免因网络拥塞等异常而影响整体的进度。</strong><br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101638074.png" alt="image-20221110163822025"><br>上图Node 1负载最小。</li>
</ol>
<p><strong>元数据：</strong><br>用 ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(<em>topic</em>, “kafka!”) 创建了一条消息，我们只知道主题的名称，对于其他一些必要的信息（元数据等）却一无所知。<br>元数据是指<strong>Kafka集群的元数据</strong>，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的leader副本分配在哪个节点上，follower副本分配在哪些节点上，哪些副本在AR、ISR等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。<br>当客户端中没有需要使用的元数据信息时，比如没有指定的主题信息，或者超过metadata.max.age.ms 时间没有更新元数据都会引起<strong>元数据的更新操作</strong>。当需要更新元数据时，会先挑选出leastLoadedNode，然后向这个Node发送MetadataRequest请求来获取具体的元数据信息。这个<strong>更新操作是由Sender线程发起的</strong>，在创建完MetadataRequest之后同样会存入InFlightRequests，之后的步骤就和发送消息时的类似。</p>
<h3 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h3><p><strong>acks</strong><br>这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。acks 是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。<br><strong>acks参数有3种类型的值：</strong><br>（都是字符串类型，注意不是整数类型）</p>
<ul>
<li><strong>acks=1</strong></li>
</ul>
<p>默认值即为1。生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息无法写入leader副本，比如在leader 副本崩溃、重新选举新的 leader 副本的过程中，那么生产者就会收到一个错误的响应，为了避免消息丢失，生产者可以选择重发消息。如果消息写入leader副本并返回成功响应给生产者，且在被其他follower副本拉取之前leader副本崩溃，那么此时消息还是会丢失，因为新选举的leader副本中并没有这条对应的消息。acks设置为1，是消息可靠性和吞吐量之间的折中方案。</p>
<ul>
<li><strong>acks=0</strong></li>
</ul>
<p>生产者发送消息之后不需要等待任何服务端的响应。如果在消息从发送到写入Kafka的过程中出现某些异常，导致Kafka并没有收到这条消息，那么生产者也无从得知，消息也就丢失了。在其他配置环境相同的情况下，acks 设置为0 可以达到最大的吞吐量。</p>
<ul>
<li><strong>acks=-1或acks=all</strong></li>
</ul>
<p>生产者在消息发送之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。在其他配置环境相同的情况下，acks 设置为-1（all）可以达到最强的可靠性。但这并不意味着消息就一定可靠，因为ISR中可能只有leader副本，这样就退化成了acks=1的情况。</p>
<p><strong>max.request.size</strong><br>这个参数用来限制生产者客户端能发送的消息的最大值，默认值为 1048576B，即1MB。一般情况下，这个默认值就可以满足大多数的应用场景了。不建议随便更改这个值的大小。</p>
<p><strong>retries和retry.backoff.ms</strong><br>retries参数用来配置生产者重试的次数，默认值为0，即在发生异常的时候不进行任何重试动作。<br>重试还和另一个参数retry.backoff.ms有关，这个参数的默认值为100，它用来设定两次重试之间的时间间隔，避免无效的频繁重试。</p>
<p><strong>linger.ms</strong><br>这个参数用来指定生产者发送 ProducerBatch 之前等待更多消息（ProducerRecord）加入ProducerBatch 的时间，默认值为 0。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费者与消费组"><a href="#消费者与消费组" class="headerlink" title="消费者与消费组"></a>消费者与消费组</h3><p>消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。<br><strong>例如：</strong></p>
<blockquote>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101638748.png" alt="image-20221110163847697"><br>主题中共有4个分区（Partition）：P0、P1、P2、P3。有两个消费组A和B都订阅了这个主题，消费组A中有4个消费者（C0、C1、C2和C3），消费组B中有2个消费者（C4和C5）。按照Kafka默认的规则，最后的分配结果是消费组A中的每一个消费者分配到1个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。<br>消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，我们可以增加（或减少）消费者的个数来提高（或降低)整体的消费能力。</p>
</blockquote>
<p>Kafka 同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合：</p>
<ol>
<li><strong>点对点</strong>：如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</li>
<li><strong>发布订阅</strong>：如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。<h3 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h3>一个正常的消费逻辑需要具备以下几个步骤：<br>（1）配置消费者客户端参数及创建相应的消费者实例<br>（2）订阅主题<br>（3）拉取消息并消费<br>（4）提交消费位移<br>（5）关闭消费者实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootkafka.chapter01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;topic-demo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> <span class="string">&quot;group.demo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, brokerList);</span><br><span class="line">        properties.put(<span class="string">&quot;group.id&quot;</span>, groupId);</span><br><span class="line">        </span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="comment">// 订阅主题 topic</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">        </span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接受的消息：&quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="必要的参数配置-1"><a href="#必要的参数配置-1" class="headerlink" title="必要的参数配置"></a>必要的参数配置</h4></li>
</ol>
<p><strong>bootstrap.servers：</strong><br>该参数的释义和生产者客户端 KafkaProducer 中的相同，用来 指 定 连 接 Kafka 集 群 所 需 的 broker 地 址 清 单，具 体 内容 形 式 为host1：port1，host2：post，可以设置一个或多个地址，中间用逗号隔开，此参数的默认值为“”。注意这里并非需要设置集群中全部的broker地址，消费者会从现有的配置中查找到全部的Kafka集群成员。这里设置两个以上的broker地址信息，当其中任意一个宕机时，消费者仍然可以连接到Kafka集群上。<br><strong>group.id：</strong><br>消费者隶属的消费组的名称，默认值为“”。如果设置为空，则会报出异常：Exception in thread “main”org.apache.kafka.common.errors.InvalidGroupIdException：The configured groupId is invalid。一般而言，这个参数需要设置成具有一定的业务意义的名称。<br><strong>key.deserializer 和 value.deserializer：</strong><br>与生产者客户端 KafkaProducer中的key.serializer和value.serializer参数对应。org.apache.kafka.common.serialization.StringDeserializer<br><strong>简化配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class="line">properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,brokerList);</span><br><span class="line">properties.put(ConsumerConfig.GROUP_ID_CONFIG,groupId);</span><br></pre></td></tr></table></figure>
<h4 id="订阅主题与分区"><a href="#订阅主题与分区" class="headerlink" title="订阅主题与分区"></a>订阅主题与分区</h4><p>一个消费者可以订阅一个或多个主题</p>
<p><strong>subscribe</strong><br>可以以集合的形式订阅多个主题，也可以以正则表达式的形式订阅特定模式的主题。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101639429.png" alt="image-20221110163912377"></p>
<blockquote>
<p>通过 subscribe（）方法订阅主题具有消费者自动再均衡的功能，在多个消费者的情况下可以根据分区分配策略来自动分配各个消费者与分区的关系。当消费组内的消费者增加或减少时，分区分配关系会自动调整，以实现消费负载均衡及故障自动转移。因为ConsumerRebalanceListener类型参数的方法</p>
</blockquote>
<p><strong>assign</strong><br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101639374.png" alt="image-20221110163924338"></p>
<blockquote>
<p>过assign（）方法订阅分区时，是不具备消费者自动均衡的功能</p>
</blockquote>
<ul>
<li>参数partitions：用来指定需要订阅的分区集合。</li>
<li>TopicPartition：表示主题-分区</li>
</ul>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101639898.png" alt="image-20221110163934859"></p>
<blockquote>
<p>订阅topic-demo主题中分区编号为0的分区：<br>consumer.assign(Arrays.<em>asList</em>(new TopicPartition(<em>topic</em>, 0)));</p>
</blockquote>
<blockquote>
<p>集合订阅的方式subscribe（Collection）、正则表达式订阅的方式subscribe（Pattern）和指定分区的订阅方式 assign（Collection）分表代表了三种不同的订阅状态：AUTO_TOPICS、AUTO_PATTERN和USER_ASSIGNED（如果没有订阅，那么订阅状态为NONE）。然而这三种状态是互斥的，在一个消费者中只能使用其中的一种，否则会报出IllegalStateException异常</p>
</blockquote>
<p><strong>问题：如何获得某个主题的元数据信息（多少个分区等）？</strong><br>**partitionsFor **方法可以用来查询指定主题的元数据信息。</p>
<blockquote>
<p>public class PartitionInfo {<br>    private final String topic;  主题名称<br>    private final int partition;  分区编号<br>    private final Node leader;  分区的leader副本所在的位置<br>    private final Node[] replicas; 分区的AR集合<br>    private final Node[] inSyncReplicas; 分区的ISR集合<br>    private final Node[] offlineReplicas;  分区的OSR集合<br>}</p>
</blockquote>
<p>通过partitionFor（）方法的协助，我们可以通过assign（）方法来实现订阅主题（全部分区）的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查出该主题的所有元数据（各个分区等）</span></span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(topic);</span><br><span class="line"><span class="keyword">if</span> (partitionInfos != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//遍历（可以拿到该主题的每个分区）</span></span><br><span class="line">    <span class="keyword">for</span> (PartitionInfo partitionInfo : partitionInfos) &#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partitionInfo.topic(),partitionInfo.partition()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer.assign(partitions);</span><br></pre></td></tr></table></figure>

<p><strong>unsubscribe</strong><br>取消主题的订阅：既可以取消通过 subscribe（Collection）方式实现的订阅，也可以取消通过subscribe（Pattern）方式实现的订阅，还可以取消通过 assign（Collection）方式实现的订阅。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101640152.png" alt="image-20221110164005117"></p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>Kafka所提供的反序列化器有ByteBufferDeserializer、ByteArrayDeserializer、BytesDeserializer、DoubleDeserializer、FloatDeserializer、IntegerDeserializer、LongDeserializer、ShortDeserializer、StringDeserializer，它们分别用于ByteBuffer、ByteArray、Bytes、Double、Float、Integer、Long、Short 及String类型的反序列化，这些序列化器也都实现了 Deserializer 接口，与KafkaProducer中提及的Serializer接口一样，Deserializer接口也有三个方法。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101640182.png" alt="image-20221110164018134"><br>可以自己定义哦（前提要与生产者的序列化一致)。</p>
<h4 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h4><p>Kafka中的消费是基于<strong>拉模式</strong>的。消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll（）方法，而poll（）方法返回的是所订阅的主题（分区）上的一组消息。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101640785.png" alt="image-20221110164034747"></p>
<blockquote>
<p>poll（）方法只是拉取一下消息而已，但就其内部逻辑而言并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容</p>
</blockquote>
<p><strong>ConsumerRecord</strong><br>消费者消费到的每条消息的类型为<strong>ConsumerRecord</strong>（注意与ConsumerRecords的区别），这个和生产者发送的消息类型ProducerRecord相对应，不过ConsumerRecord中的内容更加丰富。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerRecord</span>&lt;K, V&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> _NO_TIMESTAMP _= -<span class="number">1L</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> _NULL_SIZE _= -<span class="number">1</span>;</span><br><span class="line">_<span class="comment">/** _**_@deprecated _**_*/</span></span><br><span class="line">_<span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> _NULL_CHECKSUM _= -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String topic; 	主题的名称</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> partition;	分区的编号</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> offset;	消息在所属分区的偏移量</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;	时间戳</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimestampType timestampType;	时间戳的类型</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> serializedKeySize;		key经过序列化之后的大小</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> serializedValueSize;		value经过序列化之后的大小</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Headers headers;	消息的头部内容</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> K key;	消息的键</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> V value;	消息的值</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;Integer&gt; leaderEpoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll（）方法的返回值类型是 ConsumerRecords，它用来表示一次拉取操作所获得的消息集，内部包含了若干ConsumerRecord，它提供了一个iterator（）方法来循环遍历消息集内部的消息。</p>
<p><strong>ConsumerRecords</strong><br>ConsumerRecords类提供了一个<strong>records（TopicPartition）</strong>方法来获取消息集中指定分区的消息，此方法的定义如下：<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101641455.png" alt="image-20221110164115418"></p>
<ul>
<li>ConsumerRecords.partitions（）方法用来获取消息集中所有分区<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"><span class="comment">//records.partitions()获取消息集中所有分区</span></span><br><span class="line"><span class="keyword">for</span> (TopicPartition topicPartition : records.partitions()) &#123;</span><br><span class="line">    <span class="comment">//遍历所有主题-分区查询记录</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(topicPartition)) &#123;</span><br><span class="line">        System.out.println(record.partition() + <span class="string">&quot;:&quot;</span> + record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 ConsumerRecords类中还提供了<strong>按照主题维度来进行消费的方法</strong>，这个方法是records（TopicPartition）的重载方法，但是没有类似于 partitions（）的方法来获取消息集中所包含的主题列表。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101641254.png" alt="image-20221110164132213"><br>如果要按照主题维度来进行消费，那么只能根据消费者订阅主题时的列表来进行逻辑处理了。下面的示例演示了如何使用ConsumerRecords中的**record（String topic)**方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">List&lt;String&gt; topicList = Arrays.asList(topic1,topic2);</span><br><span class="line">consumer.subscribe(topicList);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (String topic : topicList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(topic)) &#123;</span><br><span class="line">            System.out.println(record.topic() + record.partition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，<strong>count（）</strong>方法用来计算出消息集中的消息个数，返回类型是int；<strong>isEmpty（）</strong>方法用来判断消息集是否为空，返回类型是boolean；<strong>empty（）</strong>方法用来获取一个空的消息集，返回类型是ConsumerRecord＜K，V＞。</p>
<h4 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h4><p><strong>概念</strong><br>对于Kafka中的分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中对应的位置。对于消费者而言，它也有一个offset的概念，消费者使用offset来表示消费到分区中某个消息所在的位置。</p>
<ul>
<li>对于消息在分区中的位置，我们将offset称为“偏移量”</li>
<li>对于消费者消费到的位置，将 offset 称为“位移”，有时候也会更明确地称之为“消费位移”</li>
</ul>
<p><strong>为什么需要记录offect？</strong><br>在每次调用poll（）方法时，它返回的是还没有被消费过的消息集（不考虑异常情况的发生），要做到这一点，就需要记录上一次消费时的消费位移。并且这个消费位移必须做<strong>持久化保存</strong>，而不是单单保存在内存中，否则消费者重启之后就无法知晓之前的消费位移。<br>当有新的消费者加入时，那么必然会有再均衡的动作，对于同一分区而言，它可能在再均衡动作之后分配给新的消费者，如果不持久化保存消费位移，那么这个新的消费者也无法知晓之前的消费位移。</p>
<p><strong>offect保存在哪？</strong><br>旧消费者客户端中，消费位移是存储在ZooKeeper中的。而在新消费者客户端中，消费位移存储在Kafka内部的<strong>主题__consumer_offsets</strong>中。消费者在消费完消息之后需要执行消费位移的提交。</p>
<p><strong>举例子说明提交位移</strong><br>x表示某一次拉取操作中此分区消息的最大偏移量，假设当前消费者已经消费了 x 位置的消息，那么我们就可以说消费者的消费位移为x，图中也用了lastConsumedOffset这个单词来标识它。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101641301.png" alt="image-20221110164158254"><br>当前消费者需要提交的消费位移并不是 x，而是 x+1，对应于图3-6中的position</p>
<p>KafkaConsumer 类提供了** position（TopicPartition）<strong>和</strong> committed（TopicPartition）**两个方法来分别获取上面所说的position和committed offset的值。这两个方法的定义如下所示。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101642085.png" alt="image-20221110164219043"></p>
<blockquote>
<p><strong>验证结论：</strong><br>我们向某个主题中分区编号为0的分区发送若干消息，之后再创建一个消费者去消费其中的消息，等待消费完这些消息之后就同步提交消费位移，观察一下lastConsumedOffset、committed offset和position的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line"></span><br><span class="line"><span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(topic, <span class="number">0</span>);</span><br><span class="line">consumer.assign(Arrays.asList(tp));</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">lastConsumerOffset</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//当前消费的位移</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">if</span> (records.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(tp);</span><br><span class="line">    lastConsumerOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">    consumer.commitSync(); <span class="comment">//同步提交位移</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;comsumed offset is &quot;</span> + lastConsumerOffset);</span><br><span class="line">    <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> consumer.committed(tp);</span><br><span class="line">    System.out.println(<span class="string">&quot;committed offset is &quot;</span> + offsetAndMetadata.offset());</span><br><span class="line">    <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> consumer.position(tp);  <span class="comment">// 主题下一次拉取的位置</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position offset is &quot;</span> + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101642494.png" alt="image-20221110164237455"></p>
<p><strong>位移提交会出现的问题</strong></p>
<ol>
<li><strong>位移提交的动作是在消费完所有拉取到的消息之后才执行的</strong>，那么当消费x+5的时候遇到了异常，在故障恢复之后，我们重新拉取的消息是从x+2开始的。也就是说，x+2至x+4之间的消息又重新消费了一遍，故而又发生了重复消费的现象。</li>
</ol>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101642544.png" alt="image-20221110164249498"></p>
<ol start="2">
<li>当前一次poll（）操作所拉取的消息集为[x+2，x+7]，x+2代表上一次提交的消费位移，x+5表示当前正在处理的位置。<strong>如果拉取到消息之后就进行了位移提交</strong>，即提交了x+8，那么当前消费x+5的时候遇到了异常，在故障恢复之后，我们重新拉取的消息是从x+8开始的。也就是说，x+5至x+7之间的消息并未能被消费，如此便发生了消息丢失的现象。</li>
</ol>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101643443.png" alt="image-20221110164302391"></p>
<blockquote>
<p>在 Kafka 中<strong>默认的消费位移的提交方式是自动提交</strong>，这个由消费者客户端参数enable.auto.commit 配置，默认值为true。当然这个默认的自动提交不是每消费一条消息就提交一次，而是定期提交（参数auto.commit.interval.ms配置）。在Kafka消费的编程逻辑中位移提交是一大难点，自动提交消费位移的方式非常简便，它免去了复杂的位移提交逻辑，让编码更简洁。但随之而来的是重复消费和消息丢失的问题。</p>
</blockquote>
<p><strong>消息重复消费</strong><br>假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动提交消费位移之前，消费者崩溃了，那么又得从上一次位移提交的地方重新开始消费，这样便发生了重复消费的现象（对于再均衡的情况同样适用）。我们可以通过减小位移提交的时间间隔来减小重复消息的窗口大小，但这样并不能避免重复消费的发送，而且也会使位移提交更加频繁。</p>
<p><strong>消息丢失</strong><br>拉取线程A不断地拉取消息并存入本地缓存，比如在BlockingQueue中，另一个处理线程B从缓存中读取消息并进行相应的逻辑处理。假设目前进行到了第y+1次拉取，以及第m次位移提交的时候，也就是x+6之前的位移已经确认提交了，处理线程B却还正在消费x+3的消息。此时如果处理线程B发生了异常，待其恢复之后会从第m此位移提交处，也就是x+6的位置开始拉取消息，那么x+3至x+6之间的消息就没有得到相应的处理，这样便发生消息丢失的现象。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101643245.png" alt="image-20221110164318186"></p>
<p><strong>手动位移提交（推荐使用）</strong><br>手动的提交方式可以让开发人员根据程序的逻辑在合适的地方进行位移提交。<br>开启手动提交功能的前提是消费者客户端参数enable.auto.commit配置为false。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101643635.png" alt="image-20221110164332596"></p>
<p>手动提交可以细分为<strong>同步提交</strong>和<strong>异步提交</strong></p>
<ol>
<li><strong>同步提交 commitSync</strong></li>
</ol>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101643091.png" alt="image-20221110164347053"><br>（1)普通提交</p>
<blockquote>
<p>while (true){<br>    for (ConsumerRecord&lt;String, String&gt; record : records) {<br>        System.<em>out</em>.println(“接受的消息：” + record.value());<br>    }<br>    consumer.commitSync(); // 对整个消息集做同步提交<br>}</p>
</blockquote>
<p>（2）批量处理+批量提交的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">minBatchSize</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">List&lt;ConsumerRecord&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        buffer.add(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize)&#123;</span><br><span class="line">        <span class="comment">// 逻辑处理</span></span><br><span class="line">        consumer.commitSync();</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上都有重复消费的问题，如果在业务逻辑处理完之后，并且在同步位移提交前，程序出现了崩溃，那么待恢复之后又只能从上一次位移提交的地方拉取消息，由此在两次位移提交的窗口中出现了重复消费的现象。</p>
</blockquote>
<p>（3）带参数的同步位移提交<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101644307.png" alt="image-20221110164411268"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> record.offset();</span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">partition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(partition,<span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(offset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会耗费一定的性能，而示例中的这种提交方式会将性能拉到一个相当低的点。</p>
<p>（4）按分区粒度同步提交消费位移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">            <span class="comment">//do.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次取分区 offset 进行提交</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(partition,<span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(offset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>异步提交 commitAsync</strong></li>
</ol>
<p>异步提交的方式在执行的时候消费者线程不会被阻塞，可能在提交消费位移的结果还未返回之前就开始了新一次的拉取操作。异步提交可以使消费者的性能得到一定的增强。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101644849.png" alt="image-20221110164432803"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">//do....</span></span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; map, Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;******&quot;</span> + map);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;fail to commit offsets &#123;&#125;&quot;</span>, map, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制或关闭消费"><a href="#控制或关闭消费" class="headerlink" title="控制或关闭消费"></a>控制或关闭消费</h4><p>KafkaConsumer 提供了对消费速度进行控制的方法，在有些应用场景下我们可能需要暂停某些分区的消费而先消费其他分区，当达到一定条件时再恢复这些分区的消费。KafkaConsumer中使用<strong>pause（）</strong>和<strong>resume（）</strong>方法来分别实现暂停某些分区在拉取操作时返回数据给客户端和恢复某些分区向客户端返回数据的操作。</p>
<h4 id="指定位移消费"><a href="#指定位移消费" class="headerlink" title="指定位移消费"></a>指定位移消费</h4><p>在 Kafka 中每当消费者查找不到所记录的消费位移时，就会根据消费者客户端参数<strong>auto.offset.reset</strong>的配置来决定从何处开始进行消费：</p>
<ul>
<li>latest：默认。表示从分区末尾开始消费消息。</li>
<li>earliest：消费者会从起始处，也就是0开始消费。</li>
<li>none：既不从最新的消息位置处开始消费，也不从最早的消息位置处开始消费，此时会报出NoOffsetForPartitionException异常</li>
</ul>
<p><strong>seek</strong><br>我们需要一种更细粒度的掌控，可以让我们从特定的位移处开始拉取消息，而 KafkaConsumer 中的seek（）方法正好提供了这个功能，让我们得以追前消费或回溯消费。<br><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101644403.png" alt="image-20221110164454361"></p>
<blockquote>
<p>partition表示分区，而offset参数用来指定从分区的哪个位置开始消费<br>执行seek（）方法之前需要先执行一次poll（）方法，等到分配到分区之后才可以重置消费位置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeekDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;topic-demo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> <span class="string">&quot;group.demo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">initConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                  org.apache.kafka.common.serialization.StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                  StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> initConfig();</span><br><span class="line">        </span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最好设置一下时间阻塞，不然没有时间分配分区</span></span><br><span class="line">        consumer.poll(Duration.ofMillis(<span class="number">2000</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取消费者所分配到的分区信息</span></span><br><span class="line">        Set&lt;TopicPartition&gt; assignment = consumer.assignment();</span><br><span class="line">        System.out.println(assignment);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">            <span class="comment">//设置了每个分区的消费位置为10</span></span><br><span class="line">            consumer.seek(tp, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="comment">// consume record</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record.offset() + <span class="string">&quot; : &quot;</span> + record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            isRunning.set(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101645117.png" alt="image-20221110164511077"></p>
<blockquote>
<p>seek（）方法为我们提供了从特定位置读取消息的能力，我们可以通过这个方法来向前<strong>跳过若干消息</strong>，也可以通过这个方法来向后<strong>回溯若干消息</strong>，这样为消息的消费提供了很大的灵活性。seek（）方法也为我们提供了<strong>将消费位移保存在外部存储介质中的能力</strong>，还可以配合再均衡监听器来提供更加精准的消费能力。</p>
</blockquote>
<h4 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h4><p>再均衡是指分区的所属权从一个消费者转移到另一消费者的行为，它为消费组具备高可用性和伸缩性提供保障，使我们可以既方便又安全地删除消费组内的消费者或往消费组内添加消费者。</p>
<p>未完待续……..</p>
<p>参考：</p>
<p><img data-src="https://zjw-note-images.oss-cn-shanghai.aliyuncs.com/img/kafka/202211101653678.png" alt="image-20221110165303631"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
</search>
